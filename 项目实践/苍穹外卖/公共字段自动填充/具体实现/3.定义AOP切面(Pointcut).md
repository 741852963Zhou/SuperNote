
在 [[项目实践/苍穹外卖/公共字段自动填充/解决方案|解决方案]] 中，我们决定使用 [[知识库/spring框架/AOP(面向切面编程)/AOP (MOC)|AOP (MOC)]] 来拦截 `Mapper` 层的方法。这一步就是定义这个 AOP 切面类 `AutoFillAspect`，并明确“拦截谁”的规则，即==切点 (Pointcut)==。

> [!EXAMPLE] 代码实现 (Code)
> 我们在 `sky-server` 模块的 `com.sky.aspect` 包下创建 `AutoFillAspect` 类。
> ```java
> package com.sky.aspect;
>
> import com.sky.annotation.AutoFill;
> import com.sky.constant.AutoFillConstant;
> import com.sky.context.BaseContext;
> import com.sky.enumeration.OperationType;
> import lombok.SneakyThrows;
> import lombok.extern.slf4j.Slf4j;
> import org.aspectj.lang.JoinPoint;
> import org.aspectj.lang.annotation.Aspect;
> import org.aspectj.lang.annotation.Before;
> import org.aspectj.lang.annotation.Pointcut;
> import org.aspectj.lang.reflect.MethodSignature;
> import org.springframework.stereotype.Component;
> import java.lang.reflect.Method;
> import java.time.LocalDateTime;
>
> /**
>  * 自定义切面，实现公共字段自动填充处理逻辑
>  * @author 741852963zhou
>  */
> @Aspect      // 声明这是一个切面类
> @Slf4j       // Lombok 注解，自动生成 log 对象
> @Component   // 将切面类交给 Spring 容器管理
> public class AutoFillAspect {
>     /**
>      * 定义切入点 (Pointcut)
>      * 拦截 com.sky.mapper 包下所有类的方法，并且这些方法必须带有 @AutoFill 注解
>      */
>     @Pointcut("execution (* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
>     public void pointcut() {} // 这个空方法是切点的签名，用于被下面的通知引用
>
>     // ... 通知(Advice)的实现将在下一节讲解 ...
> }
> ```
>

> [!NOTE] 核心解析
> **1. `@Aspect` 注解:**
> * 这是将一个普通 Java 类声明为 [[知识库/spring框架/AOP(面向切面编程)/AOP-核心概念(Aspect,Advice,Pointcut)|AOP-核心概念(Aspect,Advice,Pointcut)]] 中**==切面 (Aspect)==**的关键。Spring AOP 会识别这个注解，并按 AOP 的方式处理它。
>
> **2. `@Component` 注解:**
> * 切面本身也是 Spring 容器中的一个 Bean，需要被 Spring 管理才能生效。`@Component` 就是将其注册为 Bean 的标准方式。
>
> **3. `@Pointcut` 注解:**
> * 用于定义==切点==，即“**拦截规则**”。它指定了哪些方法会被当前的切面拦截。
> * **切点表达式 (Pointcut Expression)**: `"execution (* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)"`
>     * `execution(...)`: 这是最常用的 [[知识库/spring框架/AOP(面向切面编程)/AOP-切点表达式(Pointcut)|AOP-切点表达式(Pointcut)]] 指示器，用于**匹配方法执行**。
>         * `*`: 匹配任意==返回类型==。
>         * `com.sky.mapper`: 匹配 `com.sky.mapper` 包。
>         * `*`: 匹配包下的==任意类==。
>         * `*`: 匹配类中的==任意方法名==。
>         * `(..)`: 匹配==任意数量、任意类型==的参数。
>     * `&&`: 逻辑“与”，表示需要同时满足两个条件。
>     * `@annotation(...)`: 这是另一个切点指示器，用于匹配**带有特定注解**的方法。
>         * `com.sky.annotation.AutoFill`: 精确指定了我们自定义的 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/1.定义注解@AutoFill|1.定义注解@AutoFill]] 注解。
>     * **==整体含义==**：拦截 `com.sky.mapper` 包下所有带有 `@AutoFill` 注解的方法。
>
> **4. `public void pointcut() {}` 方法:**
> * 这个方法本身**==不会被执行==**，它只是一个**“挂载点”**或**“签名”**。
> * `@Pointcut` 注解依附在这个方法上，使得我们可以用 `pointcut()` 这个名字来**引用**上面那条复杂的切点表达式。这在后续定义 [[知识库/spring框架/AOP(面向切面编程)/AOP-通知(Advice)|AOP-通知(Advice)]] 时非常方便，提高了代码的可读性和可复用性。

> [!TIP] 关键点：切点表达式的精确性
> 切点表达式的设计非常关键。我们使用 `execution` 划定了一个大致范围 (`com.sky.mapper.*.*(..)`），然后用 `@annotation` 进行了精确筛选 (`@AutoFill`)。
>
> 这样既保证了我们只拦截需要自动填充的方法 (如 `insert`, `update`)，又避免了拦截不需要的方法 (如 `select`, `delete`)，提高了 AOP 的效率和准确性。

---
**返回MOC：**
[[项目实践/苍穹外卖/公共字段自动填充/实现 (MOC)|实现 (MOC)]]