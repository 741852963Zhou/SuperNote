
在 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/3.定义AOP切面(Pointcut)|3.定义AOP切面(Pointcut)]] 中，我们定义了==切点 (Pointcut)== `pointcut()` 来指定拦截规则。现在，我们需要定义 **“拦截之后做什么”** ，这就是 [[知识库/spring框架/AOP(面向切面编程)/AOP-通知(Advice)|AOP-通知(Advice)]] (Advice) 的作用。

我们选择使用 `@Before` (前置通知)，因为它符合我们的需求：在目标方法 (Mapper的insert/update) **执行之前**完成字段填充。

> [!EXAMPLE] 代码实现 (Code)
> 在 `AutoFillAspect.java` 中，我们在 `pointcut()` 方法之后添加 `@Before` 通知方法。
> ```java
> package com.sky.aspect;
>
> // ... 省略 import 和类注解 ...
>
> @Aspect
> @Slf4j
> @Component
> public class AutoFillAspect {
>
>     @Pointcut("execution (* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
>     public void pointcut() {}
>
>     /**
>      * 前置通知，在通知中进行公共字段的赋值
>      * @param joinPoint 连接点，包含被拦截方法的信息
>      */
>     @SneakyThrows // Lombok 注解，简化 try-catch
>     @Before("pointcut()") // 引用上面定义的切点
>     public void before(JoinPoint joinPoint) {
>         log.info("Before AutoFillAspect...开始进行公共字段自动填充");
>
>         // 1. 获取操作类型 (INSERT or UPDATE)
>         MethodSignature signature = (MethodSignature) 
>                                    joinPoint.getSignature(); 
>                                    // 获取方法签名
>         AutoFill autoFill = signature.
>                             getMethod().
>                               getAnnotation(AutoFill.class); 
>                               // 获取方法上的 @AutoFill 注解
>         OperationType operationType = autoFill.value(); // 获取注解的 value 值 (枚举)
>
>         // 2. 获取实体对象
>         Object[] args = joinPoint.getArgs(); // 获取被拦截方法的参数数组
>         if (args == null || args.length == 0) {
>             log.warn("被拦截的方法没有参数，无法进行自动填充");
>             return; // 如果没有参数，直接返回
>         }
>         // ==约定：需要自动填充的实体对象必须是方法的第一个参数==
>         Object entity = args[0];
>
>         // 3. 准备填充的数据
>         LocalDateTime now = LocalDateTime.now(); // 当前时间
>         Long currentUserId = BaseContext.getCurrentId(); // 当前登录用户ID (通过 ThreadLocal 获取)
>
>         // 4. 根据操作类型，通过反射为对象属性赋值 (将在下一节实现)
>         if (operationType == OperationType.INSERT) {
>             // 为4个属性赋值
>             log.debug("执行 INSERT 操作的自动填充");
>             // ... 反射调用 setCreateTime, setUpdateTime, setCreateUser, setUpdateUser ...
>         } else if (operationType == OperationType.UPDATE) {
>             // 为2个属性赋值
>             log.debug("执行 UPDATE 操作的自动填充");
>             // ... 反射调用 setUpdateTime, setUpdateUser ...
>         }
>     }
> }
> ```
>

> [!NOTE] 核心解析
> **1. `@Before` 注解:**
> * 声明这是一个==前置通知==，它会在匹配 `pointcut()` 规则的目标方法**执行之前**运行 `before(JoinPoint joinPoint)` 这个方法。
> * `("pointcut()")`: 括号中的字符串引用了我们之前定义的==切点签名==。
>
> **2. `JoinPoint joinPoint` 参数:**
> * `JoinPoint` (连接点) 是 [[知识库/spring框架/AOP(面向切面编程)/AOP-JoinPoint与MethodSignature|AOP-JoinPoint与MethodSignature]] 中的核心对象。
> * 它封装了**被拦截方法的所有信息**，包括方法签名、参数等。
> * 我们用它来：
>     * `joinPoint.getSignature()`: 获取方法签名 `Signature`，然后强转为 `MethodSignature` 以便获取 `Method` 对象和注解。
>     * `joinPoint.getArgs()`: 获取被拦截方法接收到的==实际参数值== (一个 `Object` 数组)。
>
> **3. 核心逻辑步骤:**
> * **获取操作类型**: 通过 `MethodSignature` 和反射 `getAnnotation` 获取 `@AutoFill` 注解，再读取其 `value()` 属性，得到是 `INSERT` 还是 `UPDATE`。
> * **获取实体对象**: 通过 `joinPoint.getArgs()[0]` 获取到 Mapper 方法的第一个参数，我们==约定==它就是需要被填充的实体对象 (如 `Employee`, `Category`)。这里加了非空判断以增强健壮性。
> * **准备填充数据**: 获取当前时间和当前用户ID。用户ID的获取依赖于 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/6.ThreadLocal传递用户ID|6.ThreadLocal传递用户ID]]。
> * **区分操作类型**: 使用 `if-else if` 判断操作类型，为下一步 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/5.反射调用|5.反射调用]] 做准备。

> [!TIP] 关键点：约定大于配置
> 我们约定“==需要自动填充的实体对象必须是方法的第一个参数==”。这是一个常见的 AOP 实践，它简化了切面逻辑。如果我们不这样做，就需要在切面中遍历 `args` 数组，判断哪个参数是我们需要操作的实体，会增加复杂性。

---
**返回MOC：**
[[项目实践/苍穹外卖/公共字段自动填充/实现 (MOC)|实现 (MOC)]]