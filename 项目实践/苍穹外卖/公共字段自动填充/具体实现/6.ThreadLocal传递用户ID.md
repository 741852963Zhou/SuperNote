# 6. ThreadLocal传递用户ID

## 1. 问题背景

在 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/5.反射调用|5.反射调用]] 中，我们需要为 `create_user` 和 `update_user` 字段赋值。这两个字段需要的是**当前执行操作的用户的ID**。

然而，这个用户ID是在**请求进入系统时**被解析和验证的，通常发生在**拦截器 (Interceptor)** 或 **过滤器 (Filter)** 层面。在我们的项目中，它是在 `JwtTokenAdminInterceptor` 中通过解析 JWT 令牌获取的。

但是，我们的 `AutoFillAspect` 是在更靠后的 `Mapper` 层执行的。**拦截器和切面之间如何“隔空”传递这个用户ID呢？**

> [!WARNING] 为什么不能用方法参数传递？
> 我们不能简单地修改所有 `Service` 和 `Mapper` 方法，给它们增加一个 `userId` 参数。这会：
> 1.  **侵入业务代码**：让所有业务方法都依赖于用户ID，违反了高内聚低耦合原则。
> 2.  **工作量巨大**：需要修改大量的方法签名。

## 2. 解决方案：ThreadLocal

[[知识库/java基础/ThreadLocal|ThreadLocal]] 是 Java 提供的一种 **==线程绑定==** 机制。它可以让你在**同一个线程**的不同执行点之间，方便地存取数据，而不需要通过方法参数显式传递。

**工作原理简述：**
* 每个线程都有自己独立的 `ThreadLocal` 变量副本。
* 在线程的**某个点** (`Interceptor`)，你可以调用 `threadLocal.set(value)` 将数据存入当前线程的副本。
* 在线程的**另一个点** (`Aspect`)，你可以调用 `threadLocal.get()` 从当前线程的副本中取出之前存入的数据。
* 不同线程之间的数据是**隔离**的，互不干扰。

这完美符合我们的需求，因为一个用户的HTTP请求通常是由**同一个服务器线程**从头到尾处理的 (从 Interceptor 到 Controller 到 Service 再到 Mapper)。

## 3. 代码实现

### 3.1. 创建 ThreadLocal 工具类 `BaseContext`

我们在 `sky-common` 模块 的 `com.sky.context` 包下创建 `BaseContext` 类。

> [!EXAMPLE] BaseContext.java (Code)
> ```java
> package com.sky.context;
>
> public class BaseContext {
>
>     // 创建一个 ThreadLocal 对象，用于存储 Long 类型的用户ID
>     public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();
>
>     /**
>      * 设置当前线程的用户ID
>      * @param id 用户ID
>      */
>     public static void setCurrentId(Long id) {
>         threadLocal.set(id);
>     }
>
>     /**
>      * 获取当前线程的用户ID
>      * @return 用户ID
>      */
>     public static Long getCurrentId() {
>         return threadLocal.get();
>     }
>
>     /**
>      * 移除当前线程的用户ID (非常重要！)
>      */
>     public static void removeCurrentId() {
>         threadLocal.remove();
>     }
>
> }
> ```
>

### 3.2. 在拦截器中 `set` 值

修改 `JwtTokenAdminInterceptor`，在成功解析 JWT 并获取到 `empId` 后，立刻调用 `BaseContext.setCurrentId()`。

> [!EXAMPLE] JwtTokenAdminInterceptor.java (部分代码)
> ```java
>     public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
>         // ... (省略 JWT 解析前的代码) ...
>
>         //2、校验令牌
>         try {
>             log.info("jwt校验:{}", token);
>             Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
>             Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
>             log.info("当前员工id：{}", empId); // 这里日志格式有误，应为 {}
>             // == 在这里将解析出的员工ID存入ThreadLocal ==
>             BaseContext.setCurrentId(empId);
>             //3、通过，放行
>             return true;
>         } catch (Exception ex) {
>             //4、不通过，响应401状态码
>             response.setStatus(401);
>             return false;
>         }
>     }
> ```
>

### 3.3. 在切面中 `get` 值

回到 `AutoFillAspect` 的 `before` 通知方法中，我们可以直接调用 `BaseContext.getCurrentId()` 来获取之前存入的用户ID。

> [!EXAMPLE] AutoFillAspect.java (部分代码)
> ```java
>     @Before("pointcut()")
>     public void before(JoinPoint joinPoint) {
>         // ... (省略获取 operationType 和 entity 的代码) ...
>
>         // 3. 准备填充的数据
>         LocalDateTime now = LocalDateTime.now(); // 当前时间
>         // == 在这里从ThreadLocal中获取用户ID ==
>         Long currentUserId = BaseContext.getCurrentId();
>
>         // ... (后续的反射调用) ...
>     }
> ```
>

> [!TIP] 关键点：`remove()` 的重要性
> `ThreadLocal` 使用不当可能会导致**==内存泄漏==**。因为 Web 服务器（如 Tomcat）通常使用线程池来处理请求，线程是会被复用的。
>
> 如果我们在请求结束时不调用 `BaseContext.removeCurrentId()`，那么当这个线程被下一个请求复用时，`ThreadLocal` 中可能还**残留着上一个用户的ID**！这会导致严重的数据错乱。
>
> **最佳实践**：通常在请求处理的**最后阶段**（例如，在 `Interceptor` 的 `afterCompletion` 方法，或者使用 `Filter`）调用 `BaseContext.removeCurrentId()`，确保每次请求结束后都清理 `ThreadLocal`。*(本项目代码中似乎未显式调用 remove，这是一个潜在风险点)*

---
**返回MOC：**
[[项目实践/苍穹外卖/公共字段自动填充/实现 (MOC)|实现 (MOC)]]