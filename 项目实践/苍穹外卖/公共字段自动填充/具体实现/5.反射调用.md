# 5. 反射调用

在 [[项目实践/苍穹外卖/公共字段自动填充/具体实现/4.实现AOP通知(before)|4.实现AOP通知(before)]] 中，我们已经获取了需要填充的==实体对象 (entity)==、==操作类型 (operationType)== 以及==填充的数据 (now, currentUserId)==。

这一步的核心任务是：**无论 `entity` 是 `Employee`、`Category` 还是其他任何实体，我们都需要一种通用的方式来调用它们的 `setCreateTime`, `setUpdateTime`, `setCreateUser`, `setUpdateUser` 方法**。

这就是 [[知识库/java基础/Java-反射/Java-反射 (MOC)|Java-反射 (MOC)]] 发挥作用的地方。

> [!EXAMPLE] 代码实现 (Code - 已调整换行)
> 我们在 `AutoFillAspect.java` 的 `before` 通知方法内部，添加具体的反射调用逻辑。
> ```java
>         // ... (省略前面获取 operationType, entity, now, currentUserId 的代码) ...
>
>         // 4. 根据操作类型，通过反射为对象属性赋值
>         if (operationType == OperationType.INSERT) {
>             // 为4个属性赋值
>             log.debug("执行 INSERT 操作的自动填充");
>             try {
>                 // 获取 set 方法的 Method 对象
>                 Method setCreateTime = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_CREATE_TIME, LocalDateTime.class);
>                 Method setUpdateTime = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
>                 Method setCreateUser = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_CREATE_USER, Long.class);
>                 Method setUpdateUser = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
>
>                 // 通过反射调用目标对象的方法
>                 setCreateTime.invoke(entity, now);
>                 setUpdateTime.invoke(entity, now);
>                 setCreateUser.invoke(entity, currentUserId);
>                 setUpdateUser.invoke(entity, currentUserId);
>             } catch (Exception e) {
>                 log.error("反射调用设置公共字段时出错", e);
>             }
>         } else if (operationType == OperationType.UPDATE) {
>             // 为2个属性赋值
>             log.debug("执行 UPDATE 操作的自动填充");
>             try {
>                 // 获取 set 方法的 Method 对象
>                 Method setUpdateTime = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_UPDATE_TIME, LocalDateTime.class);
>                 Method setUpdateUser = entity.getClass()
>                         .getDeclaredMethod(AutoFillConstant.SET_UPDATE_USER, Long.class);
>
>                 // 通过反射调用目标对象的方法
>                 setUpdateTime.invoke(entity, now);
>                 setUpdateUser.invoke(entity, currentUserId);
>             } catch (Exception e) {
>                 log.error("反射调用设置公共字段时出错", e);
>             }
>         }
> ```
>

> [!NOTE] 核心解析
> **1. `entity.getClass()`:**
> * 这是获取一个对象==运行时类型==的 [[知识库/java基础/Java-反射/Java-反射-Class对象|Java-反射-Class对象]] 的标准方法。无论 `entity` 是 `Employee` 还是 `Category`，`getClass()` 都能返回它对应的 `Class` 对象（“结构图”）。
>
> **2. `getDeclaredMethod(String name, Class<?>... parameterTypes)`:**
> * 这是 [[知识库/java基础/Java-反射/Java-反射-Method对象|Java-反射-Method对象]] 的核心方法之一，用于从 `Class` 对象（“结构图”）中**查找指定名称和参数类型的方法**。
> * `AutoFillConstant.SET_CREATE_TIME` 等常量存储了我们要查找的方法名字符串（如 `"setCreateTime"`）。使用常量类避免了“硬编码”字符串，提高了代码的可维护性。
> * `LocalDateTime.class`, `Long.class`: 这些是方法的==参数类型==。`getDeclaredMethod` 必须知道完整的方法签名（方法名 + 参数类型列表）才能精确找到唯一的方法。
> * `getDeclaredMethod` 可以获取到 `public`, `protected`, `default` (package) access, 和 `private` 方法，但**不包括继承的方法**。对于 `setter` 方法，通常是 `public` 的，所以使用 `getMethod` 也可以，但 `getDeclaredMethod` 更常用，因为它也能处理非 `public` 的情况（虽然这里不需要）。
>
> **3. `Method.invoke(Object obj, Object... args)`:**
> * 这是 [[知识库/java基础/Java-反射/Java-反射-Method对象|Java-反射-Method对象]] 的核心执行方法。它允许你在指定的对象上**==动态调用==**这个 `Method` 对象所代表的方法。
> * `entity`: 第一个参数 `obj` 指定了要**在哪一个对象实例上**调用这个方法。
> * `now`, `currentUserId`: 后续的可变参数 `args` 提供了调用该方法时需要**传递的实际参数值**。参数的数量和类型必须与 `getDeclaredMethod` 时指定的 `parameterTypes` 严格匹配。
> * **==效果==**：`setCreateTime.invoke(entity, now)` 这行代码在运行时的效果等同于直接写 `entity.setCreateTime(now)`，但它是**动态**的，不依赖于 `entity` 的具体编译时类型。

> [!TIP] 关键点：异常处理与常量类
> * **异常处理**: 反射操作（如 `getDeclaredMethod`, `invoke`）都可能抛出受检异常 (Checked Exceptions)，例如 `NoSuchMethodException`, `IllegalAccessException`, `InvocationTargetException`。在实际代码中，必须使用 `try-catch` 块来处理这些异常。代码中使用了 Lombok 的 `@SneakyThrows` 注解来简化了这个过程（它会在编译时自动生成 `try-catch` 并包装为非受检异常，但不推荐在生产代码中滥用）。
> * **常量类**: 使用 `AutoFillConstant` 来存储方法名字符串 (如 `SET_CREATE_TIME = "setCreateTime"`) 是一个非常好的实践。这避免了在代码中直接写 `"setCreateTime"` 这样的“魔法字符串”，如果将来方法名变更（可能性不大，但仍需考虑），只需要修改 `AutoFillConstant` 这一个地方即可。

---
**返回MOC：**
[[项目实践/苍穹外卖/公共字段自动填充/实现 (MOC)|实现 (MOC)]]